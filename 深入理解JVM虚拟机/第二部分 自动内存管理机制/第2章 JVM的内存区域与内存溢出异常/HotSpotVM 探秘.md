

这篇文章我们以HotSpot VM 来探秘java对象的创建，涉及到内存分配等细节的问题。


## 1. 对象的创建
在Java程序中，时时刻刻都有对象在创建，那么在对象的创建流程是怎么样的呢？当前这里主要从内存的申请角度来讨论，设计到class的文件加载，验证等细节逻辑，我们在第7张会学习讨论。<br />在虚拟机遇到一条new指令的时候，首先会检查指令参数是否能在运行时常量池中定位到一个类的符号引用，并且检查这个类是否已经被加载解析和初始化。如果没有，首先执行class文件的加载过程(这部分细节在第7章节中讨论)。


### 1.1 申请内存的方式
接着就是申请内存，申请多少内存在类加载完成之后就可以确定，为对象分配内存就相当于从Java堆中划出一份内存出来。划分内存的方式主要用两种:

- [x] 指针碰撞

假设Java堆中的内存都是规整的，把使用的内存放在指针的一边，把未使用的内存放在右边，中间存放分界的标记指针，在需要申请内存的时候，仅需要移动等量内存单位的指针即可，这种分配方式称之为指针碰撞,如下图所示:<br />
<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/437981/1569159313827-bdd83a01-2ac6-48ef-b924-048c207031eb.png#align=left&display=inline&height=150&name=image.png&originHeight=300&originWidth=587&size=27464&status=done&style=none&width=293.5)<br />
<br />但如果Java 堆内存不是完整的,已使用的内存和未使用内存交错出现，那么就无法简单地使用指针碰撞的方式来划分内存，从而分配内存。<br />

- [x] 空闲列表

若Java堆中，已使用的内存和未使用的交错，那么无法使用指针碰撞的方式来实现分配内存，所以需要虚拟机维护一个空闲列表，记录每一块内存是否被使用，在Java堆中找到合适的内存区域，同时标记该内存区域已使用，这种方式称之为空闲列表。

选择哪种方式是由Java堆上内存是否规整决定的，Java堆内存是否规整是由VM采用的垃圾回收器是否带有内存压缩功能决定的。所以在使用Serial、ParNew等待Compact过程的收集器的时候，系统采利用的方法是指针碰撞；而使用CMS这种基于Mark-Sweep 算法的收集器时候，通常采用空闲列表。
> 垃圾回收器，如Serial、ParNew以及CMS等，我们后续专门抽出一篇学习讨论


另外需要注意的是，在Java堆上分配内存是非常频繁的问题，若在分配内存的过程中，还未来得及移动指针(指针碰撞)或者标记内存已使用(空闲列表)的情况，那么就会相互出现并发的问题。解决这一问题有两种方案: 同步处理和线程分配缓冲。对于同步处理的方案，VM通常采用CAS配上失败重试的方法保证更新的原子性操作；另外一个线程分配缓冲是是预先在各个线程中分配小块内存，称之为本地线程分配缓冲（Thread Local Allocation Buffer ）简称TLAB。哪个线程需要分配内存就在哪个线程的TLAB上分配，只有TLAB用完后才分配新的TLAB，才需要使用同步锁定处理。虚拟机使用使用TLAB，可以通过 -XX:+/-UserTLAB 参数来设定。<br />

<a name="P1q84"></a>
### 1.2 内存空间初始化
内存空间分配完成之后，VM需要将分配的内存空间初始化为0值(不包含对象头),。如果使用TLAB来实现内存分配，这一步骤亦可以放TLAB分配时候进行。这一步骤保证了我们class对象中的值不初始化就会有个默认值，比如int类型的默认值为0，boolean的初始化值为false。<br />接下来，VM要对对象进行必要的设置，包括这个对象是哪个类的实例，对象的哈希吗、GC年龄等信息，这些信息存储在对象的对象头中(Objecrt Header)。根据虚拟机当前的运行状态不同，比如说对象锁等，对象头会有不同的设置方式。<br />从VM的角度看，这时候对象已经创建完成，因为内存区域已经分配完成并初始化，但是从开发人员的角度来看，对像的创建才刚刚开始，我们<init>方法还没有执行，所有字段都还是0值。所以一般来说执行new指令后，接着会执行init方法，把对象按照开发人员的意愿记性初始化，这样一个真正可用的对象创建完成，所以这个init就可以简单的理解为我们类的构造方法。

<a name="DVa2h"></a>
## 2. 对象的内存布局
在HotSpot的虚拟机栈中，对象存储的布局可以分为3块区域： 对象头(Header) 实例数据(Instance Data)和对其填充(Padding)。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/437981/1569162161960-516e6305-952d-4064-bf2c-c245687c7779.png#align=left&display=inline&height=430&name=image.png&originHeight=860&originWidth=1250&size=217747&status=done&style=stroke&width=625)
<a name="aBKQ0"></a>
### 2.1 对象头信息
对象头信息如上图所示主要分为两部分： 存储对象自身分运行时数据，如哈希码、GC分代年龄、锁状态标记、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据长度在32bit(64位的虚拟机长度为64bit)，官方称之为Mark Word。实际情况中对象需要存储的运行时数据信息很多，已经超过了32位。但是对象头信息食欲对象自身示例数据无关的额外存储,考虑到空间效率，Mark Word 被设计为非固定长度的数据结构，以减少存储空间。<br />对象的另外一部分是类型指针，即对象指向它的类元数据的指针，VM通过这个指针来确定这个对象是哪个类的实例。<br />值得注意的是如果对象是Java数组的话，那么对象头中还存储着记录数组长度的数据块，VM可以通过Java对象的原信息获取对象的大小，但是从数组的元数据中无法确定数组的大小

> 事实上并不是所有的VM都必须在对象数据上保存类型指针，也就是查询对象的元数据不一定要经过对象本身，我本片文章的后续部分将有介绍


<a name="UIlEx"></a>
### 2.2 实例数据
对象的布局的第二部分就是实例数据，也就是程序中定义的各种类型的字段内容，不管是从父类继承下来的还是子类中定义的，都需要记录下来。这部分的存储顺序收到虚拟机分配策略参数和字段在Java源码中定义的顺序影响，HotSpot默认的分配策略为: longs/doubles 、 ints 、shorts/chars 、bytes/booleans 、oops(Orinary Object Prointer), 从分配策略上来说相同宽度的字段总是分配到一起，然后父类中定义的变量会出现在子类之前。<br />

<a name="Zigcg"></a>
### 2.3 对齐填充
对齐填充并不是必然存在的，仅仅起到占位符的作用。HotSpot虚拟机的对象大小必须是8的倍数，当对象的大小不满足该条件的时候就需要对齐填充来补全。
> 对象的三个布局中，对象头的部分长度为32bit或者64bit，再加上类型指针的空间，正好是8个字节的1倍或者2倍，所以对齐数据是为了防止实例数据这一部分不满足8字节的整数据倍



<a name="fl0YZ"></a>
## 3. 对象的访问定位
创建对象是为了使用使用对象，Java程序在运行时候通过Java虚拟机栈上的reference类型的数据来操作Java堆上的具体对象。由于reference类型值规定了其是一个执行对象的引用，并非定义这个引用影通过何种方式去访问Java堆内存的数据，所以对象的访问的方式通常取决于VM实现方式，主流的方式访问有句柄访问和直接指针。

- 如果使用句柄访问的方式，那么虚拟机会在Java堆上开辟一块内存区域用作句柄池，reference对象存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址。此时就解决了2.1中，访问对象的元数据并不一定要在对象的实例的对象头中定义类型指针，这部分信息被移动到句柄中。

![image.png](https://cdn.nlark.com/yuque/0/2019/png/437981/1569164416612-22d30647-c461-4496-9e28-2b3050d97c70.png#align=left&display=inline&height=524&name=image.png&originHeight=698&originWidth=1336&size=304238&status=done&style=none&width=1002)<br />使用句柄访问的方式，优点在于句柄地址的稳定，在VM内存频繁改变的情况下，若对象地址改变，仅仅会修改句柄的数据，而不会修改reference的数据。<br />

- 直接访问最大的优点在于速度快，减少了以此指针定位的开销，由于对象的访问非常频繁，所以这部分时间的减少，积少成多也是对程序的访问速度有较大的提升。

![image.png](https://cdn.nlark.com/yuque/0/2019/png/437981/1569164878606-3b7b30f1-1c4e-49ec-9f01-727c33110a95.png#align=left&display=inline&height=379&name=image.png&originHeight=379&originWidth=768&size=110238&status=done&style=stroke&width=768)<br />

> 就当前讨论的HotSpot虚拟机而言，其使用直接访问的方式定位对象，从整个VM行业来说，使用句柄方式访问也不再少数


- Java 堆内存的垃圾回收的评率非常高，在垃圾回收之后，内存不再连续，这时候需要对内存区域进行整理，使之内存区域连续。所以使用句柄的方式，执行数据的指针经常发生改变。
- 基于垃圾回收的考虑，所以HotSpot 虚拟机使用的是**直接访问**来实现


